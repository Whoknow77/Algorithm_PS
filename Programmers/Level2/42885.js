// 투포인터
function solution(people, limit) {
  let answer = 0;
  people.sort((a, b) => b - a);
  let l = 0;
  let r = people.length - 1;

  while (l < r) {
    let sum = people[l] + people[r];
    if (sum > limit) {
      l++;
    } else {
      l++;
      r--;
    }
    answer++;
  }
  if (l == r) answer++;
  return answer;
}

console.log(solution([70, 50, 50, 50, 50, 30, 20], 100));

// people을 내림차순으로 정렬한다.
// 첫번째 수(가장 큰 수)와 마지막 수(가장 작은 수)를 더한 값을 구한다.
// limit을 넘는다면 (첫번째 수만 배에 태우기 때문에) 다음 수로 향하도록 l++ 한다.
// limit을 넘지 않으면 (첫번째 수와 마지막 수를 배에 태우기 때문에) 양 끝에서 다음 수로 향하도록 l++, r-- 한다.
// 혼자 탄 배 추가를 위해 answer++
// 함께 탄 배 추가를 위해 answer++
// 만약 people[l] == people[r] 즉, 계산되지 않은 마지막 숫자가 남았다면, 이 숫자 혼자 타는 배를 추가하기 위해 answer++ 한다.

// 이 방법을 사용하면서 걱정했던 점은

// people = [60, 40, 30] limit=100 처럼

// 60-40의 짝이 존재하는데 60-30의 짝을 태우게 되는 경우가 있지 않을까? 그래서 비효율적으로 태우게 되면 어쩌지? 하는 걱정이었다.

// 그러나 이런 경우에도.. 정렬이 되어있기 때문에 답이 달라지진 않는다.

// 60-30을 태웠을때 문제가 되려면 70처럼 30의 더 적절한 짝이 있어야 하는데

// 그런 경우엔 내림차순 정렬 때문에

// people = [70, 60, 40, 30]

// 70-30, 60-40이 타게 되기 때문에... 걱정하지 않아도 된다.
